<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width">
    <title>GLB Draco Model Viewer with Interactive Hotspots</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        /* ツールチップ用の基本スタイル */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: transparent;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            display: none;
            z-index: 10;
        }

        /* Preview image - shows while loading */
        #preview-image {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #f0f0f0;
            z-index: 999;
            transition: opacity 0.5s ease;
        }

        #preview-image.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Loading indicator */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.85);
            padding: 30px 40px;
            border-radius: 12px;
            z-index: 1001;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        /* Spinner animation */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4fc3f7;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
    <!-- Import Map: モジュールの解決先 -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
</head>

<body>
    <!-- Preview image - shown while loading -->
    <div id="preview-image"></div>

    <!-- Loading indicator -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading model...</div>
    </div>

    <!-- ツールチップ要素を作成 -->
    <div id="tooltip" class="tooltip"></div>

    <!-- ES Modulesとしてライブラリを読み込み -->
    <script type="module">
        import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
        import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
        import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
        import { DRACOLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/DRACOLoader.js";

        // シーン・カメラ・レンダラーの初期設定
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 10);

        // COOLING: Reduce antialiasing for less heat
        const renderer = new THREE.WebGLRenderer({
            antialias: false, // Disable for better performance and less heat
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Force 1x for cooler operation
        document.body.appendChild(renderer.domElement);

        // OrbitControls の設定
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // PERFORMANCE: Track interaction state
        let isUserInteracting = false;
        let lastInteractionTime = Date.now();
        let needsRender = true;
        let isScrolling = false;
        let isVisible = true; // Track if iframe is visible on screen

        controls.addEventListener('change', () => {
            lastInteractionTime = Date.now();
            needsRender = true;
        });

        // COOLING: Detect when iframe is visible/hidden
        if ('IntersectionObserver' in window) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    isVisible = entry.isIntersecting;
                    if (isVisible) {
                        lastInteractionTime = Date.now();
                        needsRender = true;
                    }
                });
            }, { threshold: 0.1 });
            observer.observe(document.body);
        }

        // COOLING: Simplified helpers for less GPU load
        scene.add(new THREE.GridHelper(50, 25)); // Reduced from 50x50 to 50x25
        scene.add(new THREE.AxesHelper(5));
        scene.add(new THREE.AmbientLight(0xffffff, 0.5)); // Increased ambient, less directional
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); // Reduced intensity
        directionalLight.position.set(10, 10, 10);
        directionalLight.castShadow = false; // Disable shadows for performance
        scene.add(directionalLight);

        // Draco loader setup for compressed GLB files
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        dracoLoader.preload();

        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);

        // ===== MODEL CONFIGURATION =====

        // Model file
        const modelURL = "model-compressed.glb";

        // Preview image - shown while loading (improves perceived performance)
        // Put a screenshot or render of your model here
        const previewImageURL = "preview.jpg";  // Change to your preview image
        // Or use: "preview.png", "model-screenshot.jpg", etc.
        // Or leave empty: "" to disable preview

        // Note: This is a large file (269 MB)
        // Loading will take 30-60 seconds depending on your connection
        // For faster loading, consider:
        // 1. Compressing with Draco (see COMPRESS-LARGE-MODEL.md)
        // 2. Creating LOD levels (see lod-viewer.html)
        // 3. Splitting into parts (see split-model-viewer.html)

        // Alternative options:
        // const modelURL = "model-compressed.glb";  // If you compress it
        // const modelURL = "https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf";  // Test model

        let model;
        const loadingEl = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');
        const previewImage = document.getElementById('preview-image');

        // Set preview image if provided
        if (previewImageURL) {
            previewImage.style.backgroundImage = `url('${previewImageURL}')`;
        }

        async function loadModel() {
            try {
                const gltf = await new Promise((resolve, reject) => {
                    loader.load(
                        modelURL,
                        resolve,
                        (xhr) => {
                            if (xhr.lengthComputable) {
                                const percent = (xhr.loaded / xhr.total) * 100;
                                loadingText.textContent = `Loading... ${Math.round(percent)}%`;
                            } else {
                                loadingText.textContent = 'Loading...';
                            }
                        },
                        reject
                    );
                });

                model = gltf.scene;
                scene.add(model);

                // Hide loading indicator and preview image
                loadingEl.style.display = 'none';
                previewImage.classList.add('hidden');

                // Remove preview after fade completes
                setTimeout(() => {
                    if (previewImage.parentNode) {
                        previewImage.parentNode.removeChild(previewImage);
                    }
                }, 500);

                console.log("GLB model loaded successfully", model);

                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                controls.target.copy(center);

                // Camera positioning - adjust based on model size
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 2;

                // カメラ位置を設定（左前から見下ろす角度）
                camera.position.set(-cameraZ * 0.7, cameraZ * 0.3, cameraZ* 0.9);
                camera.lookAt(center);
                camera.updateProjectionMatrix();

                controls.update();

                // Cleanup
                dracoLoader.dispose();

            } catch (error) {
                console.error("Error loading GLB model:", error);
                loadingText.textContent = 'Error loading model. Check console.';
                loadingEl.style.background = 'rgba(139, 0, 0, 0.9)';
            }
        }
        loadModel();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // State management for highlighting
        let currentHighlightedObject = null;
        let originalMaterial = null;

        // Tooltip element
        const tooltip = document.getElementById("tooltip");

        // Helper function to get risk number from object
        function getRiskNumberFromObject(object) {
            // Try object name first
            if (object.name && objectNameMapping[object.name] !== undefined) {
                return objectNameMapping[object.name];
            }
            // Try userData
            if (object.userData && object.userData.riskPoint !== undefined) {
                return object.userData.riskPoint;
            }
            // Try parent's name
            if (object.parent && object.parent.name && objectNameMapping[object.parent.name] !== undefined) {
                return objectNameMapping[object.parent.name];
            }
            return null;
        }

        // PERFORMANCE: Throttled mouse move handler for hover effects
        let lastMouseMove = 0;
        let mouseTimeout;

        renderer.domElement.addEventListener("mousemove", (event) => {
            if (!model) return;

            const now = Date.now();
            if (now - lastMouseMove < 50) return; // Throttle to 20fps
            lastMouseMove = now;

            isUserInteracting = true;
            lastInteractionTime = now;
            needsRender = true;

            clearTimeout(mouseTimeout);
            mouseTimeout = setTimeout(() => {
                isUserInteracting = false;
            }, 150);

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(model.children, true);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const riskNumber = getRiskNumberFromObject(intersected);

                if (riskNumber !== null) {
                    renderer.domElement.style.cursor = 'pointer';

                    // Show tooltip
                    if (riskDescriptions[riskNumber]) {
                        tooltip.textContent = riskDescriptions[riskNumber];
                        tooltip.style.display = "block";
                        tooltip.style.left = (event.clientX + 10) + "px";
                        tooltip.style.top = (event.clientY + 10) + "px";
                    }

                    // Highlight object
                    if (currentHighlightedObject !== intersected) {
                        // Restore previous object
                        if (currentHighlightedObject && originalMaterial) {
                            currentHighlightedObject.material = originalMaterial;
                        }

                        // Highlight new object
                        if (intersected.isMesh) {
                            originalMaterial = intersected.material;
                            currentHighlightedObject = intersected;
                            intersected.material = highlightMaterial;
                        }
                    }
                } else {
                    renderer.domElement.style.cursor = 'auto';
                    tooltip.style.display = "none";

                    // Restore material if highlighting
                    if (currentHighlightedObject && originalMaterial) {
                        currentHighlightedObject.material = originalMaterial;
                        currentHighlightedObject = null;
                        originalMaterial = null;
                    }
                }
            } else {
                renderer.domElement.style.cursor = 'auto';
                tooltip.style.display = "none";

                // Restore material
                if (currentHighlightedObject && originalMaterial) {
                    currentHighlightedObject.material = originalMaterial;
                    currentHighlightedObject = null;
                    originalMaterial = null;
                }
            }
        });

        // Click event handler - navigate to risk point page
        renderer.domElement.addEventListener("click", (event) => {
            if (!model) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(model.children, true);

            console.log("Clicked objects:", intersects);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const riskNumber = getRiskNumberFromObject(intersected);

                console.log("Risk number:", riskNumber);

                if (riskNumber !== null) {
                    const formattedNumber = riskNumber < 10 ? "0" + riskNumber : riskNumber;
                    const url = `https://kasetsu-digital.com/r${formattedNumber}_c01/`;

                    console.log("Navigating to:", url);

                    // Brief highlight before navigation
                    setTimeout(() => {
                        window.top.location.href = url;
                    }, 200);
                }
            }
        });

        // COOLING: Smart animation loop - aggressive frame limiting to reduce heat
        let lastRenderTime = 0;
        const minFrameInterval = 33; // Cap at 30fps max for cooler operation

        function animate() {
            requestAnimationFrame(animate);

            const now = Date.now();
            const timeSinceInteraction = now - lastInteractionTime;
            const timeSinceLastRender = now - lastRenderTime;

            const controlsChanged = controls.update();

            // STOP rendering if: scrolling, not visible, or too soon since last frame
            if (isScrolling || !isVisible || timeSinceLastRender < minFrameInterval) {
                return; // Skip rendering
            }

            // Render if: user interacting, controls changed, or recently active
            if (isUserInteracting || controlsChanged || timeSinceInteraction < 2000 || needsRender) {
                renderer.render(scene, camera);
                lastRenderTime = now;
                needsRender = false;
            }
            // After 2 seconds idle, render at 3fps (very low to reduce heat)
            else if (timeSinceInteraction < 10000 && timeSinceInteraction % 333 < 16) {
                renderer.render(scene, camera);
                lastRenderTime = now;
            }
            // After 10 seconds, stop rendering completely until next interaction
        }
        animate();

        // ウィンドウリサイズ対応
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            needsRender = true;
        });

        // PERFORMANCE: Listen for scroll events from parent page
        let scrollTimeout;
        window.addEventListener('message', (event) => {
            if (event.data === 'scrolling') {
                isScrolling = true;
                // Don't render at all during scroll

                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    isScrolling = false;
                    lastInteractionTime = Date.now();
                    needsRender = true; // Force one render after scroll ends
                }, 150); // Resume rendering 150ms after scroll stops
            }
        });

        // COOLING: Pause rendering when window/tab loses focus
        window.addEventListener('blur', () => {
            isUserInteracting = false;
            isVisible = false; // Stop rendering when tab is not active
        });

        window.addEventListener('focus', () => {
            isVisible = true;
            lastInteractionTime = Date.now();
            needsRender = true;
        });

        // COOLING: Page visibility API - stop rendering when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                isVisible = false;
                isUserInteracting = false;
            } else {
                isVisible = true;
                lastInteractionTime = Date.now();
                needsRender = true;
            }
        });

        // External functions for parent window communication
        // These can be called from hello.html to highlight risk points

        window.highlightRiskPoint = function (riskNumber) {
            if (!model) return;

            // Clear previous highlight
            if (currentHighlightedObject && originalMaterial) {
                currentHighlightedObject.material = originalMaterial;
                currentHighlightedObject = null;
                originalMaterial = null;
            }

            // Find object by risk number
            model.traverse((child) => {
                if (child.isMesh) {
                    const objRiskNum = getRiskNumberFromObject(child);
                    if (objRiskNum === riskNumber) {
                        originalMaterial = child.material;
                        currentHighlightedObject = child;
                        child.material = highlightMaterial;
                        needsRender = true;
                    }
                }
            });
        };

        window.clearHighlightRiskPoint = function () {
            if (currentHighlightedObject && originalMaterial) {
                currentHighlightedObject.material = originalMaterial;
                currentHighlightedObject = null;
                originalMaterial = null;
                needsRender = true;
            }
        };

        // Helper: Log all object names to console (for mapping setup)
        window.logModelObjects = function () {
            if (!model) {
                console.log("Model not loaded yet");
                return;
            }
            console.log("=== Model Objects ===");
            model.traverse((child) => {
                if (child.isMesh) {
                    console.log(`Object: "${child.name}", Parent: "${child.parent.name}", UserData:`, child.userData);
                }
            });
        };

        console.log("💡 GLB Viewer loaded with COOLING optimizations");
        console.log("📋 Call window.logModelObjects() to see all object names");
        console.log("❄️ COOLING MODE: Max 30fps, stops on scroll/hidden, 1x pixel ratio");
        console.log("🌡️ Heat reduction: No antialiasing, simplified lighting, visibility detection");

        // Register Service Worker for caching (makes repeat visits instant!)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('✅ Service Worker registered - Repeat visits will be instant!');
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
            });
        }

    </script>
</body>

</html>